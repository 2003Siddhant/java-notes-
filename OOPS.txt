oops is basically a way for modelling software entities as a real world objects that have state(data) , behaviours(methods) AND interact with each other.

Banking Software 
        - Customer has data (name, account_id, balance, KYC details, etc.)
        - Customer can do actions (open accounts, deposit, withdraw, transfer etc.)
        - different customer behave similarly but have different values (balance differs)

    - OOP lets you represent this in code cleanly. 

-> class is basically a blueprint/template which has data members and member functions.
-> object is basically instance of the class created at runtime. ex: classname a = new classname(); obj is always created using new keyword as its stored inside heap.

a) Static variables : its declared inside a class and has only one copy and is distributed among all the objects . ex: when we create bank class and objects as its customers then we can create a static variable an increase its val inside the constructor to know how many customers are there of that bank.
b) static methods : this are accessible without creating any object of the class like we dont need to create any object to access methods of static .
c) static class : such class cant be inherited and are somewhat final.


1) Encapsulation : just binding together data and information in a single unit. like having access modifiers so that not anyone can modify our data and also data that is inserted is also valid like our age cant be negative . all members should be private and getters and setters should be available.

2) Constructors : its a function that  gets created/executed when an object is created in runtime. name should be same as class and no return type. it ensures that object starts its life in a valid state. ex: the practical use case is basically used in file opening and resource management like when we hit the server , db allocates everyone its resources .
-> it can be default , parameterized , overloaded
-> valid access modifiers are : default => only accessible within same package
 public : can be accessed from anywhere inside and outside the package
 private : accessible within the same class 
 protected : accessible only within the same package , subclasses can access even in different package.

3) Method overloading : same method name, but diff parameters. its a compile type polymorphism. Java picks the “most specific” match, by matching the parameters between the calling method and declared methods . this decision is taken during compile time ex: if method overloaded is of int and main values passed is of byte, then its compilers work to so the things.

4) Static binding:  When does the static binding happens?
 -> when the method call is resolved at compile time it is called "Static binding"
 -> static methods 
 -> final methods - always bound at compile time , because they cant be overridden and always invoked at compile time.
 -> private methods - compiler binds private methods at compile time
 -> method overloading - depends on parameters / parameter types, it is decided at compile time 

   class Parent {
                static void show(){
                    sysout("Parent");
                }
            }

  class Child extends Parent {
                static void show(){
                    sysout("Child");
                }
            }

            Parent p = new Child();  
	    p.show();   		

// we have created child object and stored its reference inside p variable . when we do p.show() it generally calls the show function of parent as At runtime, the JVM looks at the actual object that p points to and object is of child type. 
-> but for this code it will call parent class show() because method is static it is not overridden, and the method call is resolved by reference type so jvm will decide which function to call during compile time.
-> in java, a parent class variable can reference to a child object                       
                         
5) Inheritance : mechanism where a class (subclass/child class) acquires the properties and behavior of another class (parent class/superclass).  used for code reusability , local hierarchy , enable runtime polymorphism and reduces duplication.
-> represents a relationship between a superclass and subclass and it supports single inheritance and not multiple due to ambiguity.

Q) Why java doesn't support multiple inheritance 
Ans: avoid ambiguity in method resolution, data conflicts, constructor initialization issues , avoid commonly known diamond problem 
 --**Java supports multiple inheritance through interfaces - ensures clarity, type safety and predictable runtime behavior 

-> super(): by default, child class constructor always invokes superclass's no-arg constructor , constructor are not inherited but parent class constr. can be invoked using super , super always refers to the immediate parent class. super helps subclasses access parent class members when they are hidden, overridden, or need explicit constructor calls.


--> Loose coupling :designing principle where classes or modules have minimal dependency on each other. we can achieve it through runtime polymorphism .  Classes interact through well-defined interfaces or abstractions, not direct implementation details. This makes the system more flexible, maintainable, and testable
--> Tight coupling : classes/modules are highly dependent on each other and some changes in one class often require changes in others. its difficult to maintain and update and also harder to test in isolation.


6) Object Class: its the root class and super/top most class and all other class inherits from it. it provides some methods that all java objects should have like toString(), equals() and hashcode() , finalize() , wait().


7) Abstract Classes : its a class that cant be instantiated means object cant be created and its basically use mostly for laying out the blueprint of how the code structure looks like and abstract methods will always be overridden by the subclasses. it may or may not have abstract methods.
-> if a class has an abst. methods then that class must be declared abstract . abs methods are just declared without an implementation.
-> abstract modifier means that class will always be used as an superclass.
-> abstract methods will never be static or final as they will always be overridden. 
-> abstract classes are not interfaces.
-> Abstract methods are usually declared where two ore more subclasses are expected to do a similar thing in different ways through different implementations 
-> private and static methods can also not be abstract.


8) Interface : an interface in java is a "pure contract" that defines what a class "Can do" , that basically we define behaviour first, implementation later.
 an interface defines set of requirements that a class has to implement . like animal interface will only define function make-sound but wont implement it.
--> class uses implements keyword to implement an interface. class that is implementing the interface must override all the abst. methods.
->a class can implement several interfaces , an interface can extend several interfaces , java7 interface contains only "abstract" methods , java8 contains public and static meth as well.
in java9 private is also allowed.
-> Interface is used to achieve complete abstraction in java. Interface must contain abstract methods only . its also used to overcome the problem of multiple inheritance as multiple interfaces can be implemented by a single class.
-> it also enables loose coupling . ex: Real software must be: scalable , replaceable , loosely coupled
ex: suppose there are multiple Payment Gateway options like paypal , Razorpay , stripe. all have different options of payment. so we can create an interface of pay and every PaymentGateway 
class can implement it . so when the option changes we can switch the pay option as pay function will be overridden by all the classes.
-> abstract classes represent real objects , interface represents "capabilities" / "requirements", not objects .
















